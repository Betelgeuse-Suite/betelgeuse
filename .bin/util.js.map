{"version":3,"file":"util.js","sourceRoot":"","sources":["../src/util.ts"],"names":[],"mappings":";;AAAA,uBAAyB;AACzB,kCAAoC;AACpC,sCAAwC;AACxC,+BAAiC;AAEpB,QAAA,QAAQ,GAAG,UAAC,IAAY;IACnC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;QACjC,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,EAAE,UAAC,GAAG,EAAE,OAAO;YACtC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACR,MAAM,CAAC,GAAG,CAAC,CAAC;YACd,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,OAAO,CAAC,OAAO,CAAC,CAAC;YACnB,CAAC;QACH,CAAC,CAAC,CAAA;IACJ,CAAC,CAAC;SAEC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAQ,CAAC,EAAT,CAAS,CAAC,CAAC;AAC1B,CAAC,CAAA;AAEY,QAAA,YAAY,GACvB,UAAC,IAAY,IAAK,OAAA,OAAO,CAAC,OAAO,CAAC,gBAAQ,CAAC,IAAI,CAAC,CAAC,EAA/B,CAA+B,CAAC;AAEvC,QAAA,SAAS,GAAG,UAAI,CAAS;IACpC,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC;QAC1B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACvB,CAAC;IAED,MAAS,CAAC,0BAAuB,CAAC;AACpC,CAAC,CAAA;AAEY,QAAA,SAAS,GAAG,UAAC,CAAS;IACjC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,CAAC,CAAA;AAEY,QAAA,SAAS,GAAG,UAAC,IAAY,EAAE,OAAe,IAAK,OAAA,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;IACtF,EAAE,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,EAAE,UAAC,GAAG;QAC9B,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACR,MAAM,CAAC,GAAG,CAAC,CAAC;QACd,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,OAAO,EAAE,CAAC;QACZ,CAAC;IACH,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC;KACC,IAAI,CAAC,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC,EAToC,CASpC,CAAC;AAOZ,QAAA,SAAS,GAAG,UAAC,OAAe,EAAE,MAAgC,EAAE,OAAiC;IAC5G,IAAI,KAAK,GAAe,EAAE,CAAC;IAE3B,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QACzC,OAAO,IAAI,GAAG,CAAC;IACjB,CAAC;IAED,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,UAAC,GAAG,EAAE,SAAS;QACjC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACR,OAAO,CAAC,GAAG,CAAC,CAAC;YACb,MAAM,CAAC;QACT,CAAC;QAED,IAAI,OAAO,GAAG,SAAS,CAAC,MAAM,CAAC;QAE/B,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACb,MAAM,CAAC,KAAK,CAAC,CAAC;YACd,MAAM,CAAC;QACT,CAAC;QAED,SAAS,CAAC,OAAO,CAAC,UAAC,QAAQ;YACzB,IAAM,IAAI,GAAG,OAAO,GAAG,QAAQ,CAAC;YAEhC,EAAE,CAAC,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;gBACrC,MAAM,CAAC,iBAAS,CAAC,IAAI,GAAG,GAAG,EAAE,UAAC,WAAW;oBACvC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;oBAElC,EAAE,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;wBACf,MAAM,CAAC,KAAK,CAAC,CAAC;oBAChB,CAAC;gBACH,CAAC,EAAE,OAAO,CAAC,CAAC;YACd,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,EAAE,UAAC,GAAG,EAAE,OAAO;oBACtC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wBACR,OAAO,CAAC,GAAG,CAAC,CAAC;wBACb,MAAM,CAAC;oBACT,CAAC;oBAED,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,MAAA,EAAE,OAAO,SAAA,EAAE,CAAC,CAAC;oBAE9B,EAAE,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;wBACf,MAAM,CAAC,KAAK,CAAC,CAAC;oBAChB,CAAC;gBACH,CAAC,CAAC,CAAC;YACL,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAA;AAEY,QAAA,kBAAkB,GAAG,UAAC,IAAY;IAC7C,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;QACjC,MAAM,CAAC,IAAI,EAAE,UAAC,GAAG;YACf,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACR,MAAM,CAAC,GAAG,CAAC,CAAC;gBACZ,MAAM,CAAC;YACT,CAAC;YACD,OAAO,EAAE,CAAC;QACZ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAA;AAYY,QAAA,WAAW,GAAG,UAAI,EAAkB,IAAK,OAAA,UAAC,GAAM;IAG3D,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,cAAM,OAAA,GAAG,EAAH,CAAG,CAAC,CAAC;AAC3D,CAAC,EAJqD,CAIrD,CAAC;AAKW,QAAA,gBAAgB,GAAG,UAAI,EAAkB,IAAK,OAAA,UAAC,GAAM;IAChE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,cAAM,OAAA,GAAG,EAAH,CAAG,CAAC,CAAC;AAC3D,CAAC,EAF0D,CAE1D,CAAC;AAEW,QAAA,GAAG,GAAG,cAAM,OAAA,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,EAApB,CAAoB,CAAC","sourcesContent":["import * as fs from 'fs';\nimport * as Promise from 'bluebird';\nimport * as beautify from 'js-beautify';\nimport * as mkdirp from 'mkdirp';\n\nexport const readFile = (path: string) => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(path, 'utf-8', (err, content) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(content);\n      }\n    })\n  })\n    // 'hard code' the type\n    .then(s => <string>s);\n}\n\nexport const readJSONFile =\n  (path: string) => Promise.resolve(readFile(path));\n\nexport const jsonToObj = <T>(s: string): T => {\n  if (typeof s === 'string') {\n    return JSON.parse(s);\n  }\n\n  throw `${s} is not a Valid JSON!`;\n}\n\nexport const objToJson = (o: Object): string => {\n  return beautify(JSON.stringify(o));\n}\n\nexport const writeFile = (path: string, content: string) => new Promise((resolve, reject) => {\n  fs.writeFile(path, content, (err) => {\n    if (err) {\n      reject(err);\n    } else {\n      resolve();\n    }\n  })\n})\n  .then(() => undefined);\n\nexport type ReadFile = {\n  path: string;\n  content: string;\n}\n\nexport const readFiles = (dirname: string, onDone: (...args: any[]) => void, onError: (...args: any[]) => void) => {\n  var files: ReadFile[] = [];\n\n  if (dirname && dirname.slice(-1) !== '/') {\n    dirname += '/';\n  }\n\n  fs.readdir(dirname, (err, filenames) => {\n    if (err) {\n      onError(err);\n      return;\n    }\n\n    var pending = filenames.length;\n\n    if (!pending) {\n      onDone(files);\n      return;\n    }\n\n    filenames.forEach((filename) => {\n      const path = dirname + filename;\n\n      if (fs.lstatSync(path).isDirectory()) {\n        return readFiles(path + '/', (nestedFiles) => {\n          files = files.concat(nestedFiles);\n\n          if (!--pending) {\n            onDone(files);\n          }\n        }, onError);\n      } else {\n        fs.readFile(path, 'utf-8', (err, content) => {\n          if (err) {\n            onError(err);\n            return;\n          }\n\n          files.push({ path, content });\n\n          if (!--pending) {\n            onDone(files);\n          }\n        });\n      }\n    });\n  });\n}\n\nexport const makeDirRecursively = (path: string) => {\n  return new Promise((resolve, reject) => {\n    mkdirp(path, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * PassThrough takes an argument function fn and returns\n * a thunk that takes an argument a\n *\n * when the thunk is invoked, it invokes the fn() and it returns the\n * argument a.\n *\n * Works pretty well in monadic chains, such as promises,\n * when you need chain a function that creates a side effect!\n */\nexport const passThrough = <T>(fn: (a: T) => void) => (arg: T) => {\n  // If the Promise resolves, bypass it's return and send back the arg,\n  // If the promise rejects, this will ensure the chain interrupts.\n  return Promise.resolve(fn.call(fn, arg)).then(() => arg);\n};\n\n/**\n * Same as PassThrough, except that it waits for fn() to resolve!\n */\nexport const passThroughAwait = <T>(fn: (a: T) => void) => (arg: T) => {\n  return Promise.resolve(fn.call(fn, arg)).then(() => arg);\n};\n\nexport const now = () => new Date().getTime();\n"]}